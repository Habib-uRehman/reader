from django.db import models
from django.contrib.auth.models import User
import uuid
import os
from django.utils import timezone
from django.conf import settings

def profile_picture_path(instance, filename):
    """Generate a unique path for user profile pictures"""
    ext = filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{ext}"
    return os.path.join('profile_pictures', filename)

def qr_code_path(instance, filename):
    """Generate a unique path for ticket QR codes"""
    return os.path.join('qrcodes', f"{instance.ticket_id}.png")

class Operator(models.Model):
    """Model for ticket operators"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='operator_profile')
    name = models.CharField(max_length=100)
    location = models.CharField(max_length=100)
    contact_number = models.CharField(max_length=20, blank=True, null=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name
    
    def count_registered_users(self):
        """Count users registered by this operator"""
        return TicketUser.objects.filter(registered_by=self).count()
    
    def count_generated_tickets(self, ticket_type=None, status_filter=None):
        """Count tickets generated by this operator"""
        # Start with all tickets associated with users registered by this operator
        tickets = Ticket.objects.filter(user__registered_by=self)
        
        # Filter by ticket type if specified
        if ticket_type:
            tickets = tickets.filter(ticket_type=ticket_type)
            
        # Filter by status if specified
        if status_filter:
            tickets = tickets.filter(status__in=status_filter)
            
        return tickets.count()

class TicketUser(models.Model):
    """Model for storing ticket user information"""
    
    # Gender Choices
    MALE = 'male'
    FEMALE = 'female'
    OTHER = 'other'
    
    GENDER_CHOICES = [
        (MALE, 'Male'),
        (FEMALE, 'Female'),
        (OTHER, 'Other'),
    ]
    
    # Relationship Choices
    SELF = 'self'
    PARENT = 'parent'
    CHILD = 'child'
    SPOUSE = 'spouse'
    SIBLING = 'sibling'
    OTHER_REL = 'other'
    
    RELATIONSHIP_CHOICES = [
        (SELF, 'Self'),
        (PARENT, 'Parent'),
        (CHILD, 'Child'),
        (SPOUSE, 'Spouse'),
        (SIBLING, 'Sibling'),
        (OTHER_REL, 'Other'),
    ]
    
    # Fields
    user_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    full_name = models.CharField(max_length=255)
    father_name = models.CharField(max_length=255, blank=True, null=True)
    email = models.EmailField()
    phone_number = models.CharField(max_length=20)
    cnic_number = models.CharField(max_length=20)
    related_to = models.CharField(max_length=255, blank=True, null=True, 
                                 help_text="Name of primary CNIC holder if using shared CNIC")
    relationship = models.CharField(max_length=20, choices=RELATIONSHIP_CHOICES, default=SELF)
    gender = models.CharField(max_length=10, choices=GENDER_CHOICES)
    age = models.PositiveIntegerField(null=True, blank=True)
    profile_picture = models.ImageField(upload_to=profile_picture_path, null=True, blank=True)
    registered_by = models.ForeignKey(Operator, on_delete=models.SET_NULL, 
                                      null=True, related_name='registered_users')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def get_operator_name(self):
        """Get the name of the operator who created this ticket"""
        if self.created_by and hasattr(self.created_by, 'operator_profile'):
            return self.created_by.operator_profile.name
        return "Unknown"

    def __str__(self):
        return self.full_name



class TicketQuota(models.Model):
    """Model for tracking ticket quotas"""
    ticket_type = models.CharField(max_length=50, unique=True)
    total_quantity = models.PositiveIntegerField(default=0)
    sold_quantity = models.PositiveIntegerField(default=0)
    
    @property
    def remaining(self):
        return max(0, self.total_quantity - self.sold_quantity)
    
    def __str__(self):
        return f"{self.ticket_type} - {self.remaining} remaining"
    
    @classmethod
    def update_sold_count(cls, ticket_type):
        """Update the sold count for a ticket type (only counting active tickets)"""
        quota = cls.objects.get(ticket_type=ticket_type)
        # Only count active tickets - exclude deleted/tampered tickets
        sold = Ticket.objects.filter(
            ticket_type=ticket_type,
            status__in=[Ticket.UNSCANNED, Ticket.SCANNED_GATE1, Ticket.SCANNED_BOTH]
        ).count()
        quota.sold_quantity = sold
        quota.save()
        return quota

class Ticket(models.Model):
    """Model for storing ticket information"""
    
    # Ticket Types
    GAWADER_ENCLOSURE = 'Gwadar Enclosure'
    CHAMAN_ENCLOSURE = 'Chaman Enclosure'
    
    TICKET_TYPES = [
        (GAWADER_ENCLOSURE, 'Gwadar Enclosure'),
        (CHAMAN_ENCLOSURE, 'Chaman Enclosure'),
    ]
    
    TICKET_PRICES = {
        GAWADER_ENCLOSURE: 4000,
        CHAMAN_ENCLOSURE: 3000,
    }
    
    # Ticket Status Choices
    UNSCANNED = 'unscanned'
    SCANNED_GATE1 = 'scanned_gate1'
    SCANNED_BOTH = 'scanned_both'
    TAMPERED = 'tampered'
    
    STATUS_CHOICES = [
        (UNSCANNED, 'Unscanned'),
        (SCANNED_GATE1, 'Scanned at Gate 1'),
        (SCANNED_BOTH, 'Scanned at Both Gates'),
        (TAMPERED, 'Tampered'),
    ]
    
    # Fields
    ticket_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(TicketUser, on_delete=models.CASCADE, related_name='tickets')
    ticket_type = models.CharField(max_length=50, choices=TICKET_TYPES)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=UNSCANNED)
    is_tampered = models.BooleanField(default=False)
    qr_code = models.ImageField(upload_to=qr_code_path, blank=True, null=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_tickets')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Ticket {self.ticket_id} - {self.user.full_name}"
    
    def save(self, *args, **kwargs):
        # Set price based on ticket type if not already set
        if not self.price and self.ticket_type:
            self.price = self.TICKET_PRICES.get(self.ticket_type, 0)
        
        super().save(*args, **kwargs)
    
    def get_status_display_class(self):
        """Return CSS class for status display"""
        status_classes = {
            self.UNSCANNED: 'status-unscanned',
            self.SCANNED_GATE1: 'status-scanned-gate1',
            self.SCANNED_BOTH: 'status-scanned-both',
            self.TAMPERED: 'status-tampered',
        }
        return status_classes.get(self.status, '')
    
    class Meta:
        ordering = ['-created_at']



class ScanLog(models.Model):
    """Model for storing ticket scan logs"""
    
    # Gate Choices
    GATE1 = 'gate1'
    GATE2 = 'gate2'
    
    GATE_CHOICES = [
        (GATE1, 'Gate 1 (Entry)'),
        (GATE2, 'Gate 2 (Exit)'),
    ]
    
    # Fields
    log_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    ticket = models.ForeignKey(Ticket, on_delete=models.CASCADE, related_name='scan_logs')
    gate = models.CharField(max_length=10, choices=GATE_CHOICES)
    scanned_at = models.DateTimeField(auto_now_add=True)
    scanned_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    notes = models.TextField(blank=True, null=True)
    
    def __str__(self):
        return f"Scan of {self.ticket.ticket_id} at {self.get_gate_display()} on {self.scanned_at.strftime('%Y-%m-%d %H:%M')}"
    
    class Meta:
        ordering = ['-scanned_at']
        # Ensure a ticket is only scanned once at each gate
        unique_together = ['ticket', 'gate']
